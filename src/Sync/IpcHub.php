<?php

namespace Amp\Parallel\Sync;

use Amp\ByteStream\ReadableResourceStream;
use Amp\Cancellation;
use Amp\CancelledException;
use Amp\DeferredFuture;
use Amp\Socket\ResourceSocket;
use Amp\TimeoutCancellation;
use Amp\Socket;
use Amp\Socket\EncryptableSocket;
use Amp\Socket\SocketConnector;
use Revolt\EventLoop;
use const Amp\Process\IS_WINDOWS;

final class IpcHub
{
    public const DEFAULT_KEY_RECEIVE_TIMEOUT = 5;
    public const DEFAULT_KEY_LENGTH = 64;

    private int $nextId = 0;

    private Socket\ResourceSocketServer $server;

    private string $uri;

    /** @var int[] */
    private array $keys = [];

    /** @var DeferredFuture[] */
    private array $acceptor = [];

    private \Closure $accept;

    private ?string $toUnlink = null;

    /**
     * @param positive-int $keyLength Length of the random key exchanged on the IPC channel when connecting.
     * @param float $keyReceiveTimeout Timeout to receive the key on accepted connections.
     *
     * @throws Socket\SocketException
     */
    public function __construct(
        private int $keyLength = self::DEFAULT_KEY_LENGTH,
        float $keyReceiveTimeout = self::DEFAULT_KEY_RECEIVE_TIMEOUT,
    ) {
        if (IS_WINDOWS) {
            $this->uri = "tcp://127.0.0.1:0";
        } else {
            $suffix = \bin2hex(\random_bytes(10));
            $path = \sys_get_temp_dir() . "/amp-parallel-ipc-" . $suffix . ".sock";
            $this->uri = "unix://" . $path;
            $this->toUnlink = $path;
        }

        $this->server = $server = Socket\listen($this->uri);

        if (IS_WINDOWS) {
            $this->uri = "tcp://127.0.0.1:" . $this->server->getAddress()->getPort();
        }

        $keys = &$this->keys;
        $acceptor = &$this->acceptor;
        $this->accept = static function () use (&$keys, &$acceptor, $server, $keyReceiveTimeout, $keyLength): void {
            while (!empty($acceptor) && $client = $server->accept()) {
                try {
                    $received = self::readKey($client, new TimeoutCancellation($keyReceiveTimeout), $keyLength);
                } catch (\Throwable) {
                    $client->close();
                    continue; // Ignore possible foreign connection attempt.
                }

                $id = $keys[$received] ?? null;

                if ($id === null) {
                    $client->close();
                    continue; // Ignore possible foreign connection attempt.
                }

                $deferred = $acceptor[$id] ?? null;
                unset($acceptor[$id], $keys[$received]);

                if ($deferred === null) {
                    $client->close();
                    continue; // Client accept cancelled.
                }

                $deferred->complete($client);
            }
        };
    }

    public function __destruct()
    {
        $this->close();
    }

    public function isClosed(): bool
    {
        return $this->server->isClosed();
    }

    public function close(): void
    {
        $this->server->close();
        if ($this->toUnlink !== null) {
            @\unlink($this->toUnlink);
        }
    }

    public function getUri(): string
    {
        return $this->uri;
    }

    public function generateKey(): string
    {
        return \random_bytes($this->keyLength);
    }

    /**
     * @param string $key A key generated by {@see generateKey()}.
     * @param Cancellation|null $cancellation
     *
     * @return ResourceSocket
     */
    public function accept(string $key, ?Cancellation $cancellation = null): ResourceSocket
    {
        if (\strlen($key) !== $this->keyLength) {
            throw new \ValueError(sprintf(
                "Key provided is of length %d, expected %d",
                \strlen($key),
                $this->keyLength,
            ));
        }

        $id = $this->nextId++;

        if (empty($this->acceptor)) {
            EventLoop::queue($this->accept);
        }

        $this->keys[$key] = $id;
        $this->acceptor[$id] = $deferred = new DeferredFuture;

        try {
            $client = $deferred->getFuture()->await($cancellation);
        } catch (CancelledException $exception) {
            unset($this->acceptor[$id], $this->keys[$key]);
            throw $exception;
        }

        return $client;
    }

    /**
     * Note this is designed to be used in the child process/thread.
     *
     * @param ReadableResourceStream|ResourceSocket $stream
     * @param Cancellation|null $cancellation Closes the stream if cancelled.
     * @param positive-int $keyLength
     */
    public static function readKey(
        ReadableResourceStream|ResourceSocket $stream,
        ?Cancellation $cancellation = null,
        int $keyLength = self::DEFAULT_KEY_LENGTH,
    ): string {
        $key = "";

        // Read random key from $stream and send back to parent over IPC socket to authenticate.
        do {
            if (($chunk = $stream->read($cancellation, $keyLength - \strlen($key))) === null) {
                throw new \RuntimeException("Could not read key from parent", E_USER_ERROR);
            }
            $key .= $chunk;
        } while (\strlen($key) < $keyLength);

        return $key;
    }

    /**
     * Note that this is designed to be used in the child process/thread and performs a blocking connect.
     *
     * @return EncryptableSocket
     */
    public static function connect(
        string $uri,
        string $key,
        ?Cancellation $cancellation = null,
        ?SocketConnector $connector = null,
    ): EncryptableSocket {
        $connector ??= Socket\socketConnector();

        $client = $connector->connect($uri, cancellation: $cancellation);
        $client->write($key);

        return $client;
    }
}
